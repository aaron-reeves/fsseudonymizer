
#include <ar_general_purpose/strutils.h>
#include <epic_general_purpose/cph.h>
#include <epic_general_purpose/epicutils.h>

#include "cbvddata.h"

#include "cprocessor.h"

CBVDData::CBVDData( QObject* parent /* = nullptr */ ) : QObject( parent ), QList<CBVDRecord*>() {
  _processingResult = CProcessor::SUCCESS; // Value may be changed by the functions below.
  _input = nullptr;

  _errMsgs.clear();
  _passphrase = QLatin1String("");
  _nCommentRows = 0;

}


CBVDData::~CBVDData() {
  for( int i = 0; i < this->count(); ++ i )
    delete this->takeLast();
}


void CBVDData::addRecords( QCsvObject* input, const QString& passphrase, const bool excludeParish ) {
  _input = input;
  _passphrase = passphrase;
  _excludeParish = excludeParish;
  _nFields = _input->fieldCount();

  if( 0 >= _nFields ) {
    _errMsgs.append( CError::Fatal, QStringLiteral("Input file seems to be the wrong format") );
    _processingResult = CProcessor::INPUT_FILE_PROBLEM;
    return;
  }
  else {
    _nCommentRows = _input->nCommentRows();

    connect( _input, SIGNAL( nBytesRead( int ) ), this, SIGNAL( nBytesRead( int ) ) );

    _processInterrupted = false;

    int line = 0;

    while( 0 < _nFields ) {
      ++line;
      addRecord( line );
      _nFields = _input->moveNext();

      emit nLinesRead( line );

      if( _processInterrupted )
        break;
    }
  }
}


void CBVDData::addRecord( const int line ) {
  //qDebug() << "-- BEGIN CBVDData::addRecord()";

  CBVDRecord* rec = new CBVDRecord( _input, line, _passphrase, _excludeParish );

  // For now, even invalid records are saved, to the extent possible, in the CSV file.
  // The database population application may do something different.
  this->append( rec );

  if( !rec->isValid() ){
    _processingResult = CProcessor::DATA_VALIDATION_PROBLEM;
    _errMsgs.append( rec->errMsgs() );
  }

  //qDebug() << "-- DONE CBVDData::addRecord()";
}


QString CBVDData::csvFileHeader( const QString& userName, const QString& userEmail ) {
  QString result;
  result.append( "# BVD testing repository data file\n" );
  result.append( QStringLiteral( "# %1 version %2\n" ).arg( qApp->applicationName(), qApp->applicationVersion() ) );
  result.append( QStringLiteral( "# Generation date: %1\n" ).arg( QDateTime::currentDateTime().toString( QStringLiteral("dd MMM yyyy hh:mm:ss") ) ) );
  result.append( QStringLiteral( "# Generated by: %1 <%2>\n").arg( userName, userEmail ) );
  result.append( QStringLiteral( "# Encryption validity check: %1\n" ).arg( sha( QStringLiteral("SRUC University of Nottingham AHDB DairyCo"), _passphrase ) ) );

  return result;
}


bool CBVDData::writeOutput( const QString& outputPath, const QString& userName, const QString& userEmail, const bool excludeParish ) {
  //qDebug() << outputPath;

  _processInterrupted = false;

  QFile outFile( outputPath );
  if( !outFile.open( QFile::WriteOnly | QFile::Truncate ) )
    return false;
  else {
    bool includeIsValid = false;

    QTextStream out( &outFile );

    out << csvFileHeader( userName, userEmail );

    CBVDRecord* rec;
    for( int i = 0; i < this->count(); ++i ) {
      rec = this->at(i);
      if( 0 == i )
        out << rec->csvColumnHeaders( includeIsValid, excludeParish ) << "\n";
      out << rec->csvText( includeIsValid, excludeParish ) << "\n";
      _processingResult = ( _processingResult | rec->csvResult() );

      emit nLinesWritten( i+1 );

      if( _processInterrupted )
        break;
    }

    out << flush;
    outFile.close();
    return true;
  }
}


void CBVDData::interrupt() {
  _processInterrupted = true;
}







